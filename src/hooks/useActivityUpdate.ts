/**
 * Hook pour la modification d'une activit√© avec support offline-first
 * Conforme aux instructions Copilot pour pattern 2-phases
 */
import { useState, useCallback } from 'react';
import { Q } from '@nozbe/watermelondb';
import { database } from '../services/database';
import { updateActivity } from '../services/api/activities';
import StepModel from '../services/database/models/Step';

interface UseActivityUpdateResult {
    updating: boolean;
    error: string | null;
    updateActivityData: (stepId: string, activityId: string, data: any) => Promise<any | null>;
}

/**
 * Validation ObjectId MongoDB
 */
const isValidObjectId = (id: string): boolean => {
    return /^[0-9a-fA-F]{24}$/.test(id);
};

/**
 * Met √† jour une activit√© dans le step local
 */
const updateActivityInLocal = async (stepId: string, activityId: string, activityData: any): Promise<any> => {
    return await database.write(async () => {
        const stepsCollection = database.get<StepModel>('steps');

        try {
            let existingStep: StepModel;

            try {
                existingStep = await stepsCollection.find(stepId);
            } catch (directFindError) {
                console.log('‚ö†Ô∏è useActivityUpdate_new - ID direct non trouv√©, recherche par query...');
                const stepsFound = await stepsCollection
                    .query(Q.where('id', stepId))
                    .fetch();

                if (stepsFound.length === 0) {
                    throw new Error(`Step avec ID ${stepId} non trouv√© en local`);
                }

                existingStep = stepsFound[0];
            }

            // DEBUG: Examiner le contenu complet du step
            console.log('üîç useActivityUpdate_new - Contenu complet du step:', {
                stepId: existingStep.id,
                stepName: (existingStep as any).name,
                activitiesJson: (existingStep as any).activitiesJson,
                activitiesJsonType: typeof (existingStep as any).activitiesJson,
                activitiesRelation: (existingStep as any).activities,
                activitiesRelationType: typeof (existingStep as any).activities,
                allFields: Object.keys(existingStep._raw || {}).filter(key =>
                    key.includes('accommodat') || key.includes('activit')
                )
            });      // R√©cup√©rer les activit√©s actuelles
            let activities = [];
            try {
                // CORRECTION FINALE: Utiliser activitiesJson (champ JSON) et non activities (relation)
                const activitiesRaw = (existingStep as any).activitiesJson;
                console.log('üîç useActivityUpdate_new - Activit√©s brutes:', {
                    type: typeof activitiesRaw,
                    isString: typeof activitiesRaw === 'string',
                    isArray: Array.isArray(activitiesRaw),
                    value: activitiesRaw,
                    valueLength: activitiesRaw?.length,
                    valueKeys: typeof activitiesRaw === 'object' ? Object.keys(activitiesRaw || {}) : 'N/A'
                });

                if (typeof activitiesRaw === 'string') {
                    activities = JSON.parse(activitiesRaw);
                } else if (Array.isArray(activitiesRaw)) {
                    activities = activitiesRaw;
                } else if (activitiesRaw && typeof activitiesRaw === 'object') {
                    // Cas o√π c'est un objet - le convertir en array
                    console.log('‚ö†Ô∏è useActivityUpdate_new - Activit√©s est un objet, conversion en array');
                    activities = Object.values(activitiesRaw);
                } else {
                    console.log('‚ö†Ô∏è useActivityUpdate_new - Activit√©s null/undefined, initialisation array vide');
                    activities = [];
                }
            } catch (parseError) {
                console.warn('‚ö†Ô∏è useActivityUpdate_new - Erreur parsing activit√©s:', parseError);
                activities = [];
            }

            // Trouver et mettre √† jour l'activit√© - CONVERSION STRING OBLIGATOIRE
            const activityIndex = activities.findIndex((act: any) => {
                const actId = act._id?.toString() || act._id;
                return actId === activityId;
            });

            console.log('üîç useActivityUpdate_new - Recherche activit√©:', {
                activityId,
                activitiesCount: activities.length,
                foundIndex: activityIndex,
                availableIds: activities.map((act: any) => ({
                    id: act._id?.toString() || act._id,
                    name: act.name
                }))
            });

            if (activityIndex === -1) {
                console.warn('‚ö†Ô∏è useActivityUpdate_new - Activit√© non trouv√©e, tentative de cr√©ation...');

                // Cr√©er l'activit√© si elle n'existe pas
                const newActivity = {
                    _id: activityId,
                    ...activityData,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                activities.push(newActivity);

                console.log('‚úÖ useActivityUpdate_new - Activit√© cr√©√©e:', {
                    activityId,
                    name: activityData.name,
                    totalActivities: activities.length
                });

                // L'index est maintenant le dernier √©l√©ment
                const newActivityIndex = activities.length - 1;
            } else {
                // Mettre √† jour l'activit√© existante
                console.log('üîß useActivityUpdate_new - Mise √† jour activit√© existante:', {
                    activityIndex,
                    originalData: activities[activityIndex],
                    newData: activityData
                });

                activities[activityIndex] = {
                    ...activities[activityIndex],
                    ...activityData,
                    _id: activityId, // Pr√©server l'ID MongoDB
                    updatedAt: new Date().toISOString()
                };

                console.log('üîß useActivityUpdate_new - Activit√© mise √† jour:', activities[activityIndex]);
            }

            const finalActivityIndex = activityIndex === -1 ? activities.length - 1 : activityIndex;

            // PATTERN COPILOT: Pr√©parer TOUTES les donn√©es AVANT la closure
            const preparedData = {
                activitiesJsonValue: JSON.stringify(activities),
                syncStatusValue: 'pending',
                lastSyncAtValue: Date.now(), // Timestamp number pour WatermelonDB
                updatedAtValue: Date.now(),  // Timestamp number pour WatermelonDB
            };

            console.log('üîß useActivityUpdate_new - Donn√©es pr√©par√©es avant closure:', preparedData);

            // Mettre √† jour le step avec les nouvelles activit√©s
            console.log('üîß useActivityUpdate_new - D√©but mise √† jour step en base');
            await existingStep.update((step: StepModel) => {
                console.log('üîß useActivityUpdate_new - Dans closure update');

                // PATTERN DEBUG: _setRaw explicite champ par champ pour debugging
                console.log('üîß useActivityUpdate_new - _setRaw activitiesJson...');
                step._setRaw('activities', preparedData.activitiesJsonValue);

                console.log('üîß useActivityUpdate_new - _setRaw sync_status...');
                step._setRaw('sync_status', preparedData.syncStatusValue);

                console.log('üîß useActivityUpdate_new - _setRaw last_sync_at...');
                step._setRaw('last_sync_at', preparedData.lastSyncAtValue);

                console.log('üîß useActivityUpdate_new - _setRaw updated_at...');
                step._setRaw('updated_at', preparedData.updatedAtValue);

                console.log('üîß useActivityUpdate_new - Fin closure update');
            });
            console.log('üîß useActivityUpdate_new - Fin mise √† jour step en base');

            console.log('‚úÖ useActivityUpdate_new - Activit√© mise √† jour en local:', activityData.name);

            return activities[finalActivityIndex];

        } catch (error) {
            console.error('‚ùå useActivityUpdate_new - √âchec mise √† jour locale:', error);
            throw error;
        }
    });
};

/**
 * Synchronise l'activit√© sp√©cifique avec l'API
 */
const syncActivityWithAPI = async (activityId: string, activityData: any): Promise<void> => {
    try {
        console.log('üîÑ useActivityUpdate_new - D√©but sync API pour activit√©:', activityId);

        // Pr√©parer les donn√©es pour l'API activit√©
        const updateData = {
            name: activityData.name,
            type: activityData.type,
            address: activityData.address,
            latitude: activityData.latitude,
            longitude: activityData.longitude,
            startDateTime: activityData.startDateTime,
            endDateTime: activityData.endDateTime,
            duration: activityData.duration,
            typeDuration: activityData.typeDuration,
            phone: activityData.phone,
            email: activityData.email,
            website: activityData.website,
            reservationNumber: activityData.reservationNumber,
            price: activityData.price,
            currency: activityData.currency,
            trailDistance: activityData.trailDistance,
            trailElevation: activityData.trailElevation,
            trailType: activityData.trailType,
            notes: activityData.notes,
            thumbnailUri: activityData.thumbnail, // Passer l'URI comme thumbnailUri pour l'upload
        };

        console.log('üîÑ useActivityUpdate_new - Donn√©es √† envoyer √† l\'API activit√©:', {
            activityId,
            updateDataKeys: Object.keys(updateData),
            hasName: !!updateData.name,
            hasCoordinates: !!(updateData.latitude && updateData.longitude)
        });

        // Appel API pour mettre √† jour l'activit√© sp√©cifique
        const updatedActivity = await updateActivity(activityId, updateData);

        if (updatedActivity) {
            // Mettre √† jour le statut de sync en local pour le step
            const stepsCollection = database.get<StepModel>('steps');
            const steps = await stepsCollection.query().fetch();

            // Trouver le step qui contient cette activit√©
            for (const step of steps) {
                const activitiesRaw = (step as any).activitiesJson;
                if (activitiesRaw) {
                    try {
                        const activities = JSON.parse(activitiesRaw);
                        const hasActivity = activities.some((act: any) =>
                            (act._id?.toString() || act._id) === activityId
                        );

                        if (hasActivity) {
                            await database.write(async () => {
                                await step.update((s: StepModel) => {
                                    s._setRaw('sync_status', 'synced');
                                    s._setRaw('last_sync_at', Date.now());
                                });
                            });
                            break;
                        }
                    } catch (parseError) {
                        console.warn('‚ö†Ô∏è Erreur parsing activit√©s pour step:', step.id);
                    }
                }
            }

            console.log('‚úÖ useActivityUpdate_new - Sync API r√©ussie pour activit√©:', activityId);
        }

    } catch (error) {
        console.error('‚ùå useActivityUpdate_new - Erreur sync API activit√©:', error);

        // Marquer comme erreur de sync le step qui contient cette activit√©
        const stepsCollection = database.get<StepModel>('steps');
        try {
            const steps = await stepsCollection.query().fetch();

            for (const step of steps) {
                const activitiesRaw = (step as any).activitiesJson;
                if (activitiesRaw) {
                    try {
                        const activities = JSON.parse(activitiesRaw);
                        const hasActivity = activities.some((act: any) =>
                            (act._id?.toString() || act._id) === activityId
                        );

                        if (hasActivity) {
                            await database.write(async () => {
                                await step.update((s: StepModel) => {
                                    s._setRaw('sync_status', 'error');
                                    s._setRaw('last_sync_at', Date.now());
                                });
                            });
                            break;
                        }
                    } catch (parseError) {
                        console.warn('‚ö†Ô∏è Erreur parsing activit√©s pour marquage erreur:', step.id);
                    }
                }
            }
        } catch (markError) {
            console.error('‚ùå useActivityUpdate_new - Erreur marquage sync error:', markError);
        }

        // Ne pas propager l'erreur pour conserver l'exp√©rience offline-first
        console.warn('‚ö†Ô∏è useActivityUpdate_new - Sync API √©chou√©e, donn√©es locales conserv√©es');
    }
};

/**
 * Hook principal pour la mise √† jour d'une activit√©
 */
export const useActivityUpdate_new = (): UseActivityUpdateResult => {
    const [updating, setUpdating] = useState(false);
    const [error, setError] = useState<string | null>(null);

    /**
     * Fonction principale de mise √† jour - OFFLINE-FIRST
     * Strat√©gie 2-phases: Sauvegarde locale imm√©diate, puis synchronisation API en arri√®re-plan
     */
    const updateActivityData = useCallback(async (
        stepId: string,
        activityId: string,
        data: any
    ): Promise<any | null> => {
        console.log('üö∂ useActivityUpdate_new - D√©but mise √† jour:', {
            stepId,
            activityId,
            name: data.name
        });

        // Validation des IDs
        if (!isValidObjectId(stepId)) {
            const errorMsg = `ID de step invalide: ${stepId}`;
            console.error('‚ùå useActivityUpdate_new -', errorMsg);
            setError(errorMsg);
            return null;
        }

        if (!isValidObjectId(activityId)) {
            const errorMsg = `ID d'activit√© invalide: ${activityId}`;
            console.error('‚ùå useActivityUpdate_new -', errorMsg);
            setError(errorMsg);
            return null;
        }

        if (updating) {
            console.log('‚ö†Ô∏è useActivityUpdate_new - Mise √† jour d√©j√† en cours, ignor√©');
            return null;
        }

        setUpdating(true);
        setError(null);

        try {
            // PHASE 1: Sauvegarde locale IMM√âDIATE (bloquante)
            console.log('üíæ PHASE 1: Sauvegarde locale imm√©diate');
            const updatedActivity = await updateActivityInLocal(stepId, activityId, data);

            console.log('‚úÖ PHASE 1 termin√©e - Activit√© sauvegard√©e localement');

            // PHASE 2: Synchronisation API en arri√®re-plan (non-bloquante)
            console.log('üîÑ PHASE 2: Sync API en arri√®re-plan');
            Promise.resolve().then(async () => {
                await syncActivityWithAPI(activityId, data);
            });

            // Retour imm√©diat apr√®s sauvegarde locale
            console.log('‚ö° Retour imm√©diat apr√®s sauvegarde locale');
            return updatedActivity;

        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';
            console.error('‚ùå useActivityUpdate_new - Erreur:', errorMessage);
            setError(errorMessage);
            return null;
        } finally {
            setUpdating(false);
        }
    }, [updating]);

    return {
        updating,
        error,
        updateActivityData,
    };
};
